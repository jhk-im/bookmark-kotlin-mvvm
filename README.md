# bookmark_se_kotlin

* lateinit var   
-> 늦은 초기화 / 프로퍼티의 선언과 동시에 초기화하지 않아도 됨   
-> 제약이 있음   
    -> lateinit var 로 선언한 프로퍼티에서만 사용할 수 있다.   
    -> 생성자에서는 사용할 수 없다.   
    -> getter/setter 를 사용하지 않은 프로퍼티에만 사용할 수 있다.   
    -> null 허용 프로퍼티에는 사용할 수 없다.   
    -> 기초 타입 프로퍼티에는 사용할 수 없다.   
   
* fun   
코틀린의 기본 함수 형태   
fun 함수명(변수): Unit {  }   
fun 함수명(변수): 리턴타입 { return 값 }   
 
 * val 과 var 차이   
 val   
 -> 불변타입 변수   
 -> 초기에 값을 할당하면 변경할 수 없으며 변경 시 컴파일 에러가 발생   
 -> java의 final과 같다고 볼 수 있음   
 -> 코드 문맥상 val 변수가 1번 초기화 된다면 여러 값 할당 가능   
 -> 변수의 참조가 가리키는 객체의 내부 값은 변경 가능   
 
 var   
 -> 초기화 후 값 변경 가능   
 -> 다른 타입의 값을 넣을 순 없음   
 -> 이미 정의된 타입을 변경하려면 자바처럼 형변환을 해야함   
 
 * Data class   
 -> 데이터 보관 목적으로 사용하는 클래스   
 -> 프로퍼티에 대한 toString(), hashcode(), equlas(), copy() 메소드를 자동으로 생성   

* constructor   
-> 생성자의 역할   
-> 자바와 다르게 변수선언을 통해 생성자를 한번에 정의 가능하다.   
-> 생성시 new 키워드를 사용하지 않음   

* Companion object   
-> 코틀린에는 static 변수, 함수가 없다.   
-> 어떠한 클래스에 인스턴스 없이 클래스 내부에 접근하고 싶을 때 compainon object를 선언한다.   
-> 단순히 클래스 이름으로 해당 객채를 사용할 수 있다.   
-> 클래스당 한개만 가질 수 있다.   

* :: 더블 콜론   
-> 리플렉션을 위해 사용한다.   
    -> 리플렉션이란 코드를 작성하는 시점에는 런타임상 컴피일된 바이트 코드에서 작성한 코드가 어디에 위치하는지 알 수 없기 때문에 바이트 코드를 이용하여 참조하려는 값을 찾기위해 사용   
-> SomeClass::class   와같이 리플렉션을 위해 사용   

* object와 class 키워드 차이점   
-> object 클래스로 정의하면 싱글턴 패턴이 적용되어 객체가 한번만 생성되도록 한다.   
-> 자바에서 싱글턴 패턴을 구현하기위해 많은작업이 걸리는데 그에비해 코틀린에선 object를 사용하여 boilerplate를 작성하지 않아도 된다.   



